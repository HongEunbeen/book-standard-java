# 3. 연산자

- 피연산자의 타입이 `int`보다 작은 타입이면 `int`로 변환된다.

    ```java
    byte + short => int + int => int
    char + short => int + int => int
    ```

- 부호 연산자는 `boolean`형과 `char`을 제외한 기본형에만 사용가능하다.

- 나누는 수로 `0`을 사용할 수 없다.

    → `0`으로 나누면, 컴파일은 정상적으로 되지만 실행 시 오류 발생

    → 부동 소수점 값인 `0.0f` `0.0d` 로 나누는 것은 가능하지만 결과는 `infinity`가 출력된다.

- 상수 또는 리터럴 간의 연산은 실행 과정동안 변하는 값이 아니다.

    → 컴파일 시에 컴파일러가 계산해 결과로 대체하기때문에 코드를 효율적으로 생성한다.

    ```java
    //컴파일 전
    char a = 'a' + 1;
    //컴파일 후
    char a = 'b';
    //컴파일 타임에 결과가 대체된다.

    char a1 = c1 + 1; //->int를 char로 대입하려고 하기때문에 error가 발생한다.
    ```

    → sec에 하루로 저장시 `'86400'`으로 저장하는 것 보다 `'60*60*24'`로 하는 것이 좋다. 컴파일때 계산되므로 실행시 성능차이는 없다.

- `Math.round()`

    → 매개변수로 받은 값을 소수점 첫째 자리에서 반올림하고 그 결과를 정수로 돌려주는 메서드

- 나머지 연산자

    →주로 짝수, 홀수, 배수 검사에 사용

    → 나누는 수로 음수를 허용하지만 부호는 무시되므로 결과는 음수의 절대값으로 나눈 나머지와 같다

- 비교 연산자

    → 이항 연산자로 비교하는 피연산자의 탕비이 서로 다를 경우 자료형의 범위가 큰 쪽으로 자동 형변환해 타입을 일치 한 후 비교한다.

- 기본형과 참조형은 등가비교 연산자를 사용할 수 없다.

    → 형변환이 불가하기 때문이다

    → `char` ⇒ `int` (`byte`차이로)

- 정수형과 달리 실수형은 근사값으로 저장되므로 오차가 발생할 수 있다.

    ```java
    10.0 == 10.0f //True
    0.1 == 0.1f //False
    ```

    → 2진수로 변환하는 과정에서 오차 발생
    (`float` 타입을 더 정밀도가 높은 `Double` 타입으로 형변환했다고 해서 오차 적어지지는 않는다)

    → `float`타입과 `double`타입의 값을 올바른 결과를 위해 비교하려면 두가지 방법 존재

    1. `double` 타입의 값을 `float`로 형변화 한 다음 비교
    2. 소수점 앞 자리만 잘라서 비교

- 조건 연산자의 식1과 식2, 이 두 피연산자의 타입이 다른 경우, 이항 연산자처럼 산술 변환이 발생한다.

- 대입 연산자 `lvalue` `rvalue`

     → `lvalue` = 대입 연산자의 왼쪽 피연산자
    (반드시 변수처럼 값을 변경할 수 있는 것이여야 함, 리터럴이나 상수같이 값을 저장할 수 없는 것은 `lvalue` X)

    → `rvalue` = 대입 연산자의 오른쪽 피연산자
    (변수뿐만 아니라 식이나 상수 등이 모두 가능)