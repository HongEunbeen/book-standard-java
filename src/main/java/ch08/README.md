# 8장 예외처리

- 프로그램이 실행 중 어떤 원인에 의해 오작동을 하거나 비정상적으로 종료되는 경우
→ 원인 : 프로그램 에러 또는 오류

```
컴파일 에러 : 컴파일 시에 발생하는 에러
런타임 에러 : 실행 시에 발생하는 에러
논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것
```

→ 발생 시점에 따라 컴파일 에러와 런타임 에러로 나뉜다

- 소스코드를 컴파일 하면 컴파일러가 소스코드(.java)에 대한 기본적인 검수 수행 → 컴파일 에러
- 컴파일 완료하면 생성된 클래스 파일(.class) 실행 → 런타임 에러

- 런타임 에러를 방지하기 위해서는 프로그램의 실행도중 발생할 수 있는 모든 경우의 수를 고려해 이에 대한 대비 중요

    → 실행 시 발생하는 있는 프로그램 오류를 에러와 예외 두가지로 구분

```
에러(Error) : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
예외(Exception) : 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류
```

→ 둘다 런타임 에러이다!

- 에러 : 메모리 부족, 스택오버 플로우 등 복구할 수 없는 심각한 오류

    → 비정상적인 종료 막을 방법 X

- 예외 : 발생하더라도 수습될 수 있는 비교적 덜 심각한 오류

    → 프로그래머가 이에 대한 적절한 코드를 작성해 비정상적인 종료 막을 수 있음!

- 실행 시 발생할 수 있는 오류를 클래스로 정의

    ```
    1. Exception클래스와 그 자손들
     -> 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외
    		(존재하지 않은 파일의 이름, 클래스의 이름 잘못 , 데이터 형식 잘못...)
    2. RuntimeException클래스와 그 자손들
    	-> 프로그래머의 실수로 발생하는 예외
    		(배열의 범위 벗어남, null인 참조변수 호출...)
    ```

- 프로그램의 실행도중 발생 에러 어쩔 수 없지만, 예외는 프로그래머가 처리 해주어야 함

    ```
    예외 처리
    정의 : 프로그램 실행 시 발생할 수 있는 예외에 대비한 코드를 작성하는 것
    목적 : 프로그래므이 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것
    ```

    → 발생한 예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되어 처리되지 못한 예외는 JVM의 예외 처리기가 받아 예외의 원인을 화면에 출력한다.

- if문과 달리, try 블럭이나 catch 블랙 내에 포함된 문자이 하나뿐이어도 괄호를 생략할 수 없다.

- 발생한 예외의 종류와 일치하는 catch 블럭이 없으면 예외는 처리되지 않는다.

- catch블럭 내의 코드에서도 예외가 발생할 수 있기에 괄호 내에 선언된 변수는 catch 블럭 내에서만 유효하다

```
- try 블럭 내에서 예외가 발생
	1. 발생한 예외와 일치하는 catch 블럭이 있는지 확인
	2. 일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 
		전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다. 
		만일 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.

- try 블럭 내에서 예외 발생 X
	1. catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행을 계속한다.
```

→ 예외를 발생한 위치 이후에 있는 try 블럭의 문장들은 수행되지 않으므로, try 블럭에 포함시킬 코드의 범위를 잘 선택해야 한다.

- 예외가 발생하면, 발생한 예외에 해당하는 클래스의 인스턴스가 만들어 진다.

    → cathc에 선언된 참조변수의 종류와 생성된 예외 클래스의 인스턴스에 `instanceof` 연산을 이용해 검사해 검사 결과가 true인 catch 블럭을 만날 때 까지 검사는 계속된다.

- 예외 클래스의 인스턴스에 발생한 예외에 대한 정보가 담겨있다.
    - printStackTrace() 
     예외 발생 당시의 호출 스택에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.
    - getMessage() 
    발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.

    → 이 두 메서드를 통해서 예외의 발생원인을 알 수 있다.

- 멀티 catch 블럭의 등장으로 여러 catch 블럭을 | 기호를 이용해 하나의 catch 블럭으로 합칠 수 있게 되었다.

    → 연결 할 수 있는 예외 클래스의 개수에는 제한이 없다.

    → 멀티 catch블럭의 | 기호로 연결된 예외 클래스가 조상과 자손의 관계에 있다면 컴파일에러 발생
    (그냥 조상 클래스만 써주는 것과 똑같아 불필요 코드 지우라는 컴파일 에러)

    →멀티 catch 블럭 내에서는 실제로 어떤 예외가 발생한 것인지 알 수 없다.

    → 멀티 catch 블럭에 선언된 참조변수는 상수

    → 참조 변수로 멀티 catch블럭에 | 기호로 연결된 예외 클래스들의 공통 분모인 조상 예외 클래스에 선언된 멤버만 사용 가능

- throw를 사용해 프로그래머가 고의로 예외를 발생 시킴

    ```
    1. 연산자 new를 이용해 발생시키려는 예외 클래스의 객체 생성
    2. 키워드 throw를 이용해 예외 발생
    ```

    → 예외 클래스 객체 생성시 생성자에 String 넣어주면 Exception 인스턴스에 메시지로 저장된다.
    (getMessage()로 얻을 수 있음)

```
Exception 클래스들 : 예외처리를 하지 않으면 컴파일 에러 일어남(checked)
RuntimeException 클래스들 : 예외처리를 하지 않아도 컴파일 성공(unchecked)
```

 → checked : 예외 처리 강제함 

→ unchecekd  : 프로그래머에 의해 실수로 발생하는 것들이기에 예외처리를 강제하지 않음

- 메서드의 선언부에 키워드 throws 사용해 메서드 내에서 발생할 수 있는 예외 적어 예외를 메서드에 선언한다.

    ```java
    void method() throws Exception1, Exception2{ ... }
    ```

    → 만약, Exception 클래스를 메서드에 선언하면 이 메서드는 모든 종류의 예외가 발생할 가능성이 있다는 뜻

    → 메서드에 예외를 선언할 때 일반적으로 RuntimeExcepiton클래스 적지 않는다.

    → 이렇게 넘겨진 예외는 반드시 try-catch문으로 예외 처리르 해주어야 한다.

- 즉, 예외 처리를 호출한 곳으로 떠맡기는 것으로 호출스택에 따라 전달되다가 제일 마지막에 있는 main 메서드에서도 예외가 처리되지 않으면 main 메서드마저 종료되어 프로그램이 전체가 종료된다.

- try블럭에서 return 문이 실행되는 경우에도 finally블럭의 문장들이 먼저 실행 된 후에, 현재 실행 중인 메서드를 종료한다.

    →catch블럭의 문장 수행 중에 return 문을 만나도 finally 블럭의 문장들은 수행된다.

- try-with-resources

    → ()안에 객체를 생성하는 문장을 넣으면, 이 객체는 따로 호출하지 않아도 try 블럭을 벗어나는 순간 자동적으로 close()가 된다.

    - close() → catch → finally

- 사용자정의 예외 클래스도 메시지를 저장할 수 있으므로, String 을 매개변수로 받는 생성자를 추가해주어야 한다.

- 예외를 처리한 후에 인위적으로 다시 발생시키는 방법인 예외 되던지기는 하나의 예외에 대해서 예외가 발생한 메서드와 이를 호출한 메서드 양쪽 모두에서 처리해줘야 할 작업이 있을 때 사용된다.

- 예외 A가 예외 B를 발생시켰다면 A를 B 의 원인 예외라고 한다.

    ```
    Throwable initCause(Throwable cause) -> 지정한 예외를 원인 예외로 등록
    Throwable getCause() -> 원인 예외를 반환
    ```

    → 여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위해서 사용

    → checked예외를 uncheked 예외로 바꿀 수 있도록 하기 위해서 사용

    ```java
    throw new RuntimeException(new MeomoryException("메모리가 부족합니다."));
    ```