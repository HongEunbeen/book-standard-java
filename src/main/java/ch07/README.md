# 7장 객체지향 프로그래밍2

# 상속

- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

```
조상 클래스 : 부모 클래스, 상위 클래스, 기반 클래스
자손 클래스 : 자식 클래스, 하위 클래스, 파생된 클래스
```

- 클래스 간의 상속관계를 그림으로 표현한 것을 상속계층도라고 한다.

- 상속에 상속을 거듭할수록 상속받는 클래스의 멤버 개수는 점점 늘어난다.

- 생성자와 초기화 블럭은 상속되지 않는다. -> 멤버만 상속된다!

- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

- 접근 제어자가 `private`, `defualt` 멤버들은 상속되지만 자손 클래스로부터의 접근이 제한된다.

- 자손 클래스들끼리는 서로 아무런 관계도 성립되지 않는다.

### 포함관계

- 상속이외에도 클래스를 재상용하는 또 다른 방법 
→ 클래스간에 포함 관계 맺기

- 클래스 간 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것

    ```java
    class Circle {
    	Point c = new Point();
    }
    ```

- 다른 클래스를 멤버변수로 선언하여 포함시키는 것은 좋은 생각이다
→ 재사용시 보다 간결하고 손쉽게 클래스를 작성할 수 있다.

🤔  그럼, 상속관계를 맺어야 하나 포함관계를 맺어야 하나?

- 결과적으로 작성시에는 별 차이가 없어 보지이만 `'~은 ~이다(is-a)'`와 `'~은 ~을 가지고 있다(has-a)'` 문장을 넣어서 클래스 간의 관계를 명확하게 파악가능하다

    ```
    원(Circle)은 점(Point)이다. -> 상속관계
    원(Circle)은 점(Point)을 가지고 있다. -> 포함관계
    ```

    → 두 번째 문장이 더 말이 되기에 포함관계가 성립된다.

    - 상속관계 :  `'~은 ~이다(is-a)'`
    - 포함관계 : `'~은 ~을 가지고 있다(has-a)'`

    → 프로그램의 모든 클래스를 분석해 가능한 많은 관계를 맺도록 노력해서 코드의 재사용성을 높여야 한다.

- toString()은 인스턴스의 정보를 문자열로 반환할 목적으로 정의

    → 참조변수의 출력이나 덧셈연산자를 이용한 참조변수와 문자열의 결합에는 toString()이 자동적으로 호출되어 참조변수를 문자열로 대치한 후 처리

    ```java
    System.out.println("Card " + c.toString());
    System.out.println("Card " + c);
    //위 두 문장은 같다. 
    ```

- 자바에서는 오직 단일 상속만을 허용한다.

    → 다중 상속을 할 경우 `static` 라면 클래스 명으로 구분이 가능하지만 인스턴스 메서드의 경우 선언부가 같은 두 메서드를 구분할 수 있는 방법이 없다.

- 만약 다중상속으로 구현하고 싶다면 하나의 클래스를 상속 받고 나머지 클래스는 포함관계를 이용해 내부적으로 클래스 인스턴스를 생성해 사용한다.

- `Object` 클래스는 모든 클래스 상속계층도의 최상위에 있는 조상클래스이다.

    → 다른 클래스들로부터 상속 받지 않는 모든 클래스들은 컴파일 시 컴파일러가 자동적으로 `extends Object`를 추가해 상속받도록 한다.

    → `toString()`이나 `equals(Object o)`와 같은 메서드를 따로 정의하지 않고도 사용할 수 있는 이유

# 오버라이딩

- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

- 사용자들은 같은 메서드 호출 시 같은 결과를 얻을 것이라는 기대를 하기 때문에 오버라이딩으로 메서드 구현

- 오버라이딩 조건

    → 메서드의 내용만을 새로 작성하는 것으로 메서드의 선언부는 조상의 것과 완전히 일치

    ```
    이름이 같아야 한다.
    매개변수가 같아야 한다.
    반환타입이 같아야 한다.
    (JDK1.5부터는 공변 반환타입으로 반환 타입을 자손 클래스의 타입으로 변경 가능)
    ```

    → 다만, 접근 제어자, 예외는 제한된 조건하에 다르게 변경 가능하다

    - 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
    - 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
    → 주의할 점은 단순히 선언된 예외의 개수가 문제가 아니다 Exception은 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던질 수 있도록 선언한 것이다.

    → 결론적으로

    ```
    1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
    2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
    3. 인스턴스메서드를 static 메서드로 또는 그 반대로 변경할 수 없다.
    ```

- 조상클래스에 정의된 `static` 메서드 자손 클래스에서 같은 이름의 `static` 메서드로 정의 가능

    → 각 클래스의 별개의 `static` 메서드로 정의 된다(오버라이딩X)

    → `static` 멤버들은 자신들이 정의된 클래스에 묶여 있다!!!!

```
오버로딩 : 기존에 없는 새로운 메서드를 정의하는 것
오버라이딩 : 상속받은 메서드의 내용을 변경하는 것
```

- 모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장된다

    → 참조변수인 `this`와 `super`값

    → `static` 메서드는 인스턴스와 관련 X(`super` ,`this` 사용X)

- `Super`는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수

    ```
    this : 멤버변수와 지역변수의 이름이 같을 때 구별 위한 참조변수
    super : 상속받은 멤버와 자신의 멤버와 이름이 같을 때 구별 위한 참조변수
    ```

    → 조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점 제외하고 근본적으로 둘은 같다

- 조상클래스로부터 상속받은 멤버 = 자손 클래스 자신의 멤버

    → `super`대신 `this` 사용가능이지만 `super`사용 추천

- 조상 클래스에 선언된 멤버변수와 같은 이름의 멤버변수를 자손 클래스에서 중복해서 정의하는 것 가능

    → 참조변수 `super`이용해 서로 구별

- 오버라이딩시 조상 클래스의 메소드 `super`이용해 호출 가능

    → 만약 내용을 추가하는 메서드라면, 조상클래스의 메서드가 변경되더라도 변경된 내용이 자손 클래스의 메서드에 자동적으로 반영

```
this() : 같은 클래스의 다른 생성자 호출
super() : 조상 클래스의 생성자 호출
```

- 자손 클래스의 인스턴스 생성 시 자손의 멤버 + 조상의 멤버 합쳐져 하나의 인스턴스 탄생

    → 조상 클래스 멤버의 초기화 작업 수행으로 조상 생성자 호출되어야 한다...

    → 조상의 멤버들이 먼저 초기화 되어 있어야 한다.

    → 조상 클래스의 멤버변수는 조상의 생성자에 의해 초기화되도록 해야 한다.

    → 결국 마지막은 모든 클래스의 최고 조상인 `Object`클래스의 생성자인 `Object()`까지 올라가야 끝난다.

- `Object` 클래스를 제외한 코든 클래스의 생성자 첫 줄에 생성자 `this()` 또는 `super()` 반드시 호출

    → 하지 않을 시 컴파일러가 `super()`를 생성자 자동으로 첫줄에 삽입

    → 어떤 클래스의 인스턴스스 생성 시 클래스 상속관계의 최고 조상인 `Object`클래스까지 거슬러 올라가며 모든 조상클래스의 생성자가 순서대로 호출된다.

# package와 import

- 패키지란, 클래스의 묶음으로 클래스 또는 인터페이스를 포함시킬수 있다.

- 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로 클래스 효율적 관리 가능

- 클래스의 실제 이름은 패키지명을 포함한 것이다.

- 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.

    → 반드시 소스파일에서 주석과 공백을 제외한 첫 번재 문장!

- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.

- 패키지는 점을 구분자로 하여 계층구조로 구성할 수 있다.

- 패키지는 물리적으로 클래스 파일을 포함하는 하나의 디렉토리이다.

- 대소문자 허용하지만, 클래스명과 쉽게 구분 위해 소문자로 하는 것을 원칙으로 한다.

- 자바에서 기본적으로 이름없는 패키지 제공

    → 소스파일에 속할 패키지 지정않할 시 자동적으로 이름 없는 패키지에 속하게 된다.

    → 패키티 지정하지 않은 클래스들은 모두 같은 패키지(이름 없는 패키지)에 속한다.

- 클래스패스(`classpath`)는 컴파일러(`javac.exe`)나 JVM 등이 클래스의 위치를 찾는데 사용되는 경로이다.

- `import`문의 역할은 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공

    → 컴파일 시에 컴파일러는 `import`문을 통해 소스파일에 사용된 클래스들의 패키지를 알아 낸 다음, 모든 클래스이름 앞에 패키지명을 붙여준다.

- `import`문은 프로그램 성능에 전혀 영향을 미치지 않는다

    → 많이 사용하면 컴파일 시간이 조금 더 걸릴 뿐이다

    →`*` 을 사용해도 실행 시 성능상의 차이는 전혀 없다.

- `import`문에서 클래스의 이름 대신 `*` 을 사용하는 것이 하위 패키지의 클래스까지 포함하는 것은 아니다.

    ```java
    import java.util.*;
    import java.text.*;

    //위의 두 개를 대신하지 못한다.
    import java.*;
    ```

- 모든 소스파일에는 묵시적으로 `import java.lang.*`이 선언되어 있다

    → 매우 빈번히 사용되는 중요한 클래스들 속한 패키지여서 따로 지정 X해도 사용 가능
    (ex. `System String`)

- 같은 패키지 내의 클래스들은 `import`문을 지정하지 않고도 패키지명 생략 가능

- `static import`문을 사용하면 `static` 멤버를 호출할 때 클래스 이름 생략 가능하다

    ```java
    System.out.println(Math.random());

    //선언 시
    import static java.lang.Integer.*;
    import static java.lang.Math.random;
    import static java.lang.System.out;

    out.println(random());
    ```

# 제어자(modifier)

- 제어자란 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

- 제어자의 종류

    ```
    접근 제어자 : public  ,protected, default, private
    그 외 : static, final ,absctract, native, transient, synchronized, volatile, strictfp
    ```

    → 하나의 대상에 대해 여러 제어자 조합 사용 가능

    → 접근 제어자는 한 번에 네 가지 중 하나만 선택해 사용 가능

- `static`은 `클래스의` `공통적인` 의미 가진다.

    ```
    static이 사용될 수 있는 곳 : 멤버변수, 메서드, 초기화 블럭
    ```

    → 인스턴스가 아닌 클래스에 관계된 것으로 인스턴스 생성하지 않고 사용 가능

    - 멤버변수

        → 모든 인스턴스에 공통적으로 사용되는 클래스 변수

        → 클래스변수는 인스턴스를 생성하지 않고도 사용 가능

        → 클래스가 메모리에 로드될 때 생성

    - 메서드

        → 인스턴스를 생성하지 않고 호출이 가능한 static aptjem

        → static 메서드 내에서 인스턴스 멤버들 직접 사용 x

    - 초기화 블럭

        → 클래스가 메모리에 로드될 때 단 한 번만 수행

        → 주로 클래스 변수 초기화하는데 사용

- `final`은 `마지막의` `변경될 수 없는` 의미 가진다.

    ```
    final이 사용될 수 있는 곳 : 클래스, 메서드, 멤버변수, 지역변수
    ```

    - 클래스

        → 변경될 수 없는  클래스, 확장될 수 없는 클래스

        → `final`로 지정된 클래스는 다른 클래스의 조상 클래스가 될 수 없다.

        → ex. `String 클래스` `Math 클래스`

    - 메서드

        → 변경될 수 없는 메서드

        → `final`로 지정된 메서드는 오버라이딩을 통해 재정의 불가능

    - 멤버변수

        → `final`로 지정된 멤버 변수는 값을 변경할 수 없는 상수가 된다.

        → 인스턴스 변수의 경우 생성자에서 초기화 가능
        (각 인스턴스마다 `final` 붙는 멤버변수 생성자에서 초기화 하면 다른 값 갖는거 가능!
        만일 불가능하다면 모든 인스턴스는 `final` 붙는 인스턴스 변수의 값이 다 같다.)

    - 지역변수

        → `final`로 지정된 지역 변수는 값을 변경할 수 없는 상수가 된다.

- 상수는 일반적으로 선언과 동시에 초기화

- `abstract`는 `미완성의` 의미를 가진다.

    ```
    abstract가 사용될 수 있는 곳 : 클래스, 메서드
    ```

    - 클래스

        → 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.

        → 아직 완성되지 않은 메서드가 존재하는 미완성 설계도로 인스턴스 생성 불가

        → 추상 메서드가 없는 완성된 클래스(일반 메서드만 존재)에 `abstract` 붙여 추상 클래스 선언 가능
        (일반적으로 인스턴스를 생성하지 못하도록 붙인다. 클래스 자체로는 쓸모가 없지만 상속받아 우너하는 메서드만 오버라이딩 가능 → 만일 일반 클래스라면 필요 없는 메서드 잔뜩 오버라이딩,,,)

    - 메서드

        → 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.

- 접근 제어자

    → 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할

    ```
    접근 제어자가 사용될 수 있는 곳 : 클래스, 멤버변수, 메서드, 생성자
    ```

    - `private` : 같은 클래스 내에서만 접근
    - `default` : 같은 패키지 내에서만 접근
    - `protected` : 같은 패키지 내 + 다른 패키지의 자손 클래스에서 접근 가능
    - `public` : 접근 제한 없음

    ```
    public > protected > default > private
    ```

    - 클래스 : `public` `default`
    - 메서드 : `public` ,`protected`, `default`, `private`
    - 멤버변수 : `public`, `protected`, `default`, `private`
    - 지역변수 : `none`

    →접근 제어자를 사용하는 이유

    ```
    외부로부터 데이터를 보호하기 위해서
    외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
    ```

    → 결론적으로는 캡슐화를 위해서!

    - 만약 메서드에 변경이 존재할 시 접근 제어자로 변경 후 테스트 범위 측정 가능

- 하나의 소스파일에는 `public` 클래스가 단 하나만 존재할 수 있으며, 소스파일의 이름은 반드시 `public` 클래스의 이름과 같아야 한다.

- 생성자에 접근 제어자 사용으로 인스턴스의 생성 제한 가능

    → 클래스 외부에서 인스턴스 생성 불가

    → 클래스 내부에서 인스턴스 생성해 반환 메서드 생성

    → 이 메서드는 반드시 `public` 인 동시에 `static` 
    (인스턴스를 생성하지 않고도 호출할 수 있어야 함으로!!)

    - 인스턴스의 개수 제한 가능
    - 다른 클래스의 조상 불가
    → 클래스 앞에 `final` 추가해 상속할 수 없는 클래스라는 것 알리는 것 추천

- 제어자 조합시 주의 사항
    - 메서드에 `static`과 `abstract`를 함께 사용할 수 없다.

        → `static`메서드는 몸통이 있는 메서드에만 사용할 수 있다.

    - 클래스에 `abstract`와 `final`을 동시에 사용할 수 없다.

        → `final` 클래스는 확장될 수 없다는 의미고 `abstract`는 상속을 통해 완성이 되어야 하므로 둘은 모순이다.

    - `abstract`메서드의 접근 제어자가 `private`일 수 없다.

        → `abstract`메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 `private`이면, 자손 클래스에서는 접근할 수 없다.

    - 메서드에 `private`과 `final`을 같이 사용할 필요는 없다.

        → 접근 제어자가 `private`인 메서드는 오버라이딩 될 수 없기에 이 둘 중 하나만 사용해도 의미가 충분하다.

# 다형성

- 객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미

- 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현

    → 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록 함

- 같은 인스턴스라도 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.

    ```java
    CaptionTv c = new CaptionTv(); //모든 메서드 사용 가능
    Tv t = new CaptionTv(); 
    // CaptionTV 인스턴스 중에서 Tv 클래스의 멤버들(상속 받은 멤버)만 사용 가능
    ```

```
조상 타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
반대로 자손타입의 참조변수로 조상타입의 인스턴스르 참조할 수 없다.
```

→ 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 존재하지 않는 멤버를 사용하고자 할 가능성이 있으므로 허용 X

- 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.

    → 클래스는 상속을 통해 확장하지만 축소는 불가

- 기본형 변수와 같이 참조변수도 형변환이 가능 단, 상속관계에 있는 클래스 끼리만!

    ```
    자손 타입 -> 조상 타입 [Up-casting] : 형변화 생략 가능
    자손 타입 <- 조상 타입 [Down-casting] : 형변환 생략 불가
    ```

- 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.

    → 단지, 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위를 조절하는 것!

```java
public class CastingTest2 {
    public static void main(String[] args) {
        Car car = new Car();
        Car car2 = null;
        FireEngine fe = null;

        car.drive();
        fe = (FireEngine) car; //실행 중 에러 발생
        fe.drive();
        car2 = fe;
        car2.drive();
    }
}
```

- 컴파일은 성공하지만 실행시 에러 발생

    → 참조변수 `car`가 참조하고 있는 인스턴스가 `Car`타입의 인스턴스이다.
    (조상타입의 인스턴스를 자손타입의 참조변수로 참조하는 것은 허용되지 않는다.)

- 컴파일시에는 참조변수간의 타입만 체크하기 때문에 실행 시 생성될 인스턴스의 타입에 대해서는 전혀 알지 못한다.

    → 컴파일시에는 문제가 없을 수 있지만 실행 시 에러가 발생한다.

    ```
    서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, 
    참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
    그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.
    ```

- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 `instanceOf` 연산자 사용

    → `true` : 참조변수가 검사한 타입으로 형변환이 가능

    ```
    어떤 타입에 대한 instanceOf 연산의 결과가 true라는 것은 
    검사한 타입으로 형변환이 가능하다는 것을 뜻한다.
    ```

    → 값이 `null` 인 참조변수는 `false` 결과

- 멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우
    - 조상 타입의 참조변수 : 조상 클래스에 선언된 멤버변수 사용
    - 자손 타입의 참조변수 : 자손 클래스에 선언된 멤버변수 사용

    → 중복된 경우는 참조변수의 타입에 따라 달라진다.
    (중복되지 않은 경우 하나뿐이므로 선택의 여지 X)

- 메서드가 조상 클래스와 자손 클래스에 중복으로 정의된 경우(오버라이딩)
    - 어느경우라도 오버라이딩 된 메서드가 호출된다.

```
멤버변수의 경우 참조변수의 타입에 따라 달라진다.
메서드의 경우 오버라이딩된 메서드가 항상 호출된다.
```

- 참조변수의 타입에 따라 결과가 달라지는 경우

    → 오직 조상 클래스의 멤버변수와 같은 이름의 멤버변수를 자손 클래스에 중복해서 정의한 경우뿐이다!!!!

- 조상 타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다.

- `Vector`클래스
    - 내부적으로 `Object` 타입의 배열을 가지고 있어서, 이 배열에 객체를 추가하거나 제거할 수 있게 작성되어있다.
    - 동적으로 크기가 관리되는 객체배열이다.

# 추상클래스

- 추상클래스는 미완성 설꼐도에 비유할 수 있다.

    → 클래스가 미완성이라는 것은 단지, 미완성 메서드를 포함하고 있다는 것을 의미한다.

- 추상 클래스로 인스턴스는 생성할 수 없다.

- 추상 클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.

    → 추상클래스 자체로는 클래스로서의 역할을 다 못하지만 새로은 클래스 작성하는데 있어 바탕이 되는 조상클래스로서 중요한 의미 가짐

- 추상 클래스는 추상 케서드를 포함하고 있다는 것을 제외하고는 일반 클래스와 전혀 다르지 않다.

    → 추상 클래스에도 생성자 존재

    → **추상 클래스에도 멤버변수와 메서드 존재**

- 추상 메서드를 포함하고 있지 않은 완성된 클래스도 추상 클래스로 지정 가능

    → 추상 클래스로 지정되면 인스턴스는 생성이 불가하다.

- 추상 메서드는 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이다.

    → 이유는 메서드이 내용이 상속받는 클래스에 따라 달라질 수 있기에 조상 클래스에서는 선언부만 작성하고, 주석을 덧붙여 어떤 기능을 수행할 목적으로 작성되었는지 알려주고, 실제 내용은 상속받는 클래스에서 구현하도록 비워둔다.

- 추상 클래스로부터 상속받은 자손 클래스는 오버라이딩을 통해 조상인 추상 클래스의 추상 메서드 모두 구현해주어야 함

    → 만약 하나라도 구현 X 시, 자손 클래스 역시 추상 클래스로 지정(미 완성이기에)

```
추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
구체화 : 상속을 통해 클래스를 구현, 확장하는 작업
```

→ 둘은 반대되는 의미이다.

- 추상 클래스도 생성자가 있어야 한다.

- 추상메서드로 선언하는 이유는 자손 클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해서이다.

    → 자손 클래스를 작성할 때 이들이 추상메서드이므로 내요을 구현해주어야 한다는 사실을 인식하고 자신의 클래스에 알맞게 구현할 것이다.

- 만약, 모든 클래스의 조상인 `Object`클래스로 배열을 만들어 클래스를 담아 같은 메서드를 실행시킨다면 에러가 발생한다.

    → `Object` 클래스에 메서드가 미 존재

    → 추상 클래스를 상속받아 같은 메서드를 구현하도록 하면 해결

# 인터페이스

- 인터페이스는 일종의 추상클래스

    → 추상클래스처럼 추상 메서드를 가짐

    → 추상 클래스보다 추상화 정도가 높아 추상클래스와 달리 몸통을 같춘 일반 메서드 또는 멤버변수를 구성원으로 X

    → 오로지 추상메서드와 상수만을 멤버로(다른 어떠한 요소도 허용X)

    ```
    추상클래스 : 미완성 설계도
    인터페이스 : 기본 설계도
    ```

- 인터페이스도 클래스와 같이 접근제어자로 public 또는 default 사용 가능

- 인터페이스 멤버들의 제약

    ```
    - 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.(상수)
    - 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.(추상 메서드)
    	(단, static메서드와 디폴트 메서드는 예외)
    ```

    → 생략된 제어자는 컴파일 시에 컴파일러가 자동적으로 추가해준다.

- 인터페이스는 인터페이스로부터만 상속을 받을 수 있다

- 인터페이스는 다중상속이 가능하다.

- 인터페이스는 그 자체로는 인스턴스 생성 불가하며 자신에 정의도니 추상메서드의 몸통을 만들어 주는 클래스 작성 필요

    → `implements` 사용해 구현

- 인터페이스의 모든 메소드 오버라이딩 안 할시 추상 클래스로 만들어 줘야 한다.

- 구현을 한 클래스에서 오버라이딩 시 접근 제어자는 반드시 public으로 해줘야 한다.

- 인터페이스 타입의 매개변수가 갖는 의미는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야 한다는 것이다.

- 리턴 타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것이다.

- 인터페이스의 장점

    ```
    - 개발 시간 단축
    - 표준화 가능
    - 서로 관계없는 클래스들에게 관계 맺을 수 있음
    - 독립적인 프로그래밍 가능
    	(인터페이스 이용하면 클래스의 선언과 구현 분리 가능으로 실제 구현에 독립적인 프로그램 작성 가능)
    ```

```
- 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다.
- 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.
	(내용은 몰라도 된다.)
```

→ 매개변수를 통해서 인터페이스르 구현한 클래스의 인스턴스를 동적으로 제공받아 같은 기능의 다른 클래스로 대체되어도 사용하는 쪽에서는 전혀 영향을 받지 않는다. 
(클래스 `Thread`의 생성자인 `Thread(Runnable target)`이 이런 방식으로 되어있음!)

- 인터페이스의 static 메서드 역시 접근 제어자가 항상 public 이며, 생략이 가능하다

- 디폴트 메서드는 추상 메서드의 기본 구현을 제공하는 메서드로, 추상 메서드가 아니기 때문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스르 구현한 클래스르 변경하지 않아도 된다.

    → 메서드 앞에 키워드 `default`를 붙임

    → 추상 메서드와 달리 일반 메서드처럼 몸통 존재

    → 접근 제어자 `public` (생략 가능)

    ```java
    interface A {
    	default void method() {/* ... */}
    }
    ```

- 디폴트 메서드를 이용하면 인터페이스르 구현한 클래스를 변경하지 않고 인터페이스에 새로운 메서드 삽입 가능

    → 단점은 새로 추가된 디폴트 메서도와 기존의 메서드의 이름이 충돌하는 경우가 존재한다.

    1. 여러 인터페이스의 디폴트 메서드 간의 충돌

        → 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩

    2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌

        → 조상 클래스의 메서드가 상속되고 디폴트 메서드는 무시된다.

# 내부클래스

- 내부 클래스는 클래스 내에 선언된다는 점을 제외하고는 일반적인 클래스와 다르지 않다.

- 클래스에 다른 클래스를 선언하는 이유는 두 클래스가 서로 긴밀한 관계에 있기 때문이다.

    → 내부 클래스는 외부 클래스를 제외하고는 다른 클래스에서 잘 사용 X

- 내부 클래스의 장점

    ```
    - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근 가능
    - 코드의 복잡성 줄이기 가능(캡슐화)
    ```

- 내부 클래스의 유효범위와 성질이 변수와 유사하다!
    - 인스턴스 클래스

        → 외부 클래스의 인스턴스 멤버처럼 사용된다.

        → 목적 : 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언

    - 스태틱 클래스

        → 외부 클래스의 `static` 멤버처럼 사용된다.

        → 목적 : `static` 멤버, 클래스에서 사용될 목적으로 선언

    - 지역 클래스

        → 외부 클래스의 메서드, 초기화 블럭 안에  선언

        → 선언된 영역 내부에서만 사용

    - 익명 클래스

        → 클래스의 선언과 객체의 생성 동시(일회용)

        → 이름없는 클래스

- 각 내부 클래스의 선언 위치에 따라 유효범위와 접근성이 달라진다.

    → 같은 선언위치의 변수와 동일한 유효범위와 접근성을 가진다.

- 내부 클래스도 클래스이기 때문에 `abstract`와 `final` 같은 제어자 사용 가능

- 내부 클래스는 멤버변수들 처럼 `private` ,`protected` 접근 제어자 사용 가능

- 스태틱 클래스만 `static` 멤버를 가질 수 있다.

- 상수는 모든 내부 클래스에서 정의가 가능하다.

- 인스턴스클래스는 외부클래스의 인스턴스멤버 객체생성 없이 바로 사용 가능

    → 인스턴스 멤버 간에는 서로 직접 접근 가능

    → 스태틱 클래스는 외부 클래스의 인스턴스멤버 객체생성 없이 사용 불가능

- 인스턴스 클래스는 외부 클래스를 먼저 생성해야만 생성 가능하다.

    → 스태틱 클래스는 외부 클래스 생성 없이 생성 가능하다.

- 메서드 내에 지역적으로 선언된 내부 클래스는 외부에서 접근할 수 없다.

- 내부 클래스에서 외부 클래스의 변수들에 대한 접근성
    - 외부 클래스의 `private` 멤버 접근 가능
    - 스태틱 클래스 : 외부 클래스의 인스턴스 멤버 X, 스태틱 멤버 O
    - 지역 클래스 : 외부 클래스의 인스턴스 멤버 O, 스태틱 멤버 O, 같은 지역의 `final` 변수 O

        → 같은 지역의 `final` 변수만 가능한 이유는 메서드가 수행을 마치고 지역변수를 소멸한 시점에 지역 클래스의 인스턴스가 소멸된 지역 변수를 참조 가능하기 때문이다.

- 내부 클래스와 외부 클래스에 선언된 변수의 이름이 같을 때 변수 앞에 `this` 또는 `외부 클래스명.this` 붙여 구별한다.

- 익명 클래스는 이름이 없기에 생성자도 가질 수 없다.

- 익명 클래스는 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.

- 익명 클래스는 이름이 없기 때문에 `외부 클래스명$숫자.class` 의 형식으로 클래스파일명 결정